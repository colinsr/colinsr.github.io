<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Azure Application Gateway - Part 2 | Colin's blog</title>
<meta name=keywords content="load balancing,azure">
<meta name=description content="This is a continuation from part one on setting up an Azure Application Gateway Part 1.
Next on our hit list is creating an Azure VNet to hold our AppGW. The AppGW has to live in an AppGW subnet, the only other thing that can reside in the same subnet are other AppGW&rsquo;s and hopefully you&rsquo;ll only need one since the AppGW is capable of serving up to 20 sites, with various limits around authentication certs for backend re-encryption.">
<meta name=author content="Colin Detwiller">
<link rel=canonical href=https://colin.detwiller.me/posts/azureapplicationgatwaypart2/>
<meta name=google-site-verification content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style>
<link rel=icon href=https://colin.detwiller.me/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://colin.detwiller.me/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://colin.detwiller.me/favicon-32x32.png>
<link rel=apple-touch-icon href=https://colin.detwiller.me/apple-touch-icon.png>
<link rel=mask-icon href=https://colin.detwiller.me/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-70072280-3','auto'),ga('send','pageview'))</script><meta property="og:title" content="Azure Application Gateway - Part 2">
<meta property="og:description" content="This is a continuation from part one on setting up an Azure Application Gateway Part 1.
Next on our hit list is creating an Azure VNet to hold our AppGW. The AppGW has to live in an AppGW subnet, the only other thing that can reside in the same subnet are other AppGW&rsquo;s and hopefully you&rsquo;ll only need one since the AppGW is capable of serving up to 20 sites, with various limits around authentication certs for backend re-encryption.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://colin.detwiller.me/posts/azureapplicationgatwaypart2/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-01-29T10:43:42-05:00">
<meta property="article:modified_time" content="2018-01-29T10:43:42-05:00"><meta property="og:site_name" content="Colin's blog">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Azure Application Gateway - Part 2">
<meta name=twitter:description content="This is a continuation from part one on setting up an Azure Application Gateway Part 1.
Next on our hit list is creating an Azure VNet to hold our AppGW. The AppGW has to live in an AppGW subnet, the only other thing that can reside in the same subnet are other AppGW&rsquo;s and hopefully you&rsquo;ll only need one since the AppGW is capable of serving up to 20 sites, with various limits around authentication certs for backend re-encryption.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://colin.detwiller.me/posts/"},{"@type":"ListItem","position":2,"name":"Azure Application Gateway - Part 2","item":"https://colin.detwiller.me/posts/azureapplicationgatwaypart2/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Azure Application Gateway - Part 2","name":"Azure Application Gateway - Part 2","description":"This is a continuation from part one on setting up an Azure Application Gateway Part 1.\nNext on our hit list is creating an Azure VNet to hold our AppGW. The AppGW has to live in an AppGW subnet, the only other thing that can reside in the same subnet are other AppGW\u0026rsquo;s and hopefully you\u0026rsquo;ll only need one since the AppGW is capable of serving up to 20 sites, with various limits around authentication certs for backend re-encryption.","keywords":["load balancing","azure"],"articleBody":"This is a continuation from part one on setting up an Azure Application Gateway Part 1.\nNext on our hit list is creating an Azure VNet to hold our AppGW. The AppGW has to live in an AppGW subnet, the only other thing that can reside in the same subnet are other AppGW’s and hopefully you’ll only need one since the AppGW is capable of serving up to 20 sites, with various limits around authentication certs for backend re-encryption.\n$gwSubnetName = 'appgwsubnet' $subnet = New-AzureRmVirtualNetworkSubnetConfig -Name $gwSubnetName ` -AddressPrefix 10.0.0.0/28 $vnet = New-AzureRmVirtualNetwork -Name appgwvnet -ResourceGroupName appgw-RG ` -Location $location -AddressPrefix 10.0.0.0/16 -Subnet $subnet $subnet = Get-AzureRmVirtualNetworkSubnetConfig -Name $gwSubnetName ` -VirtualNetwork $vnet OK, now we can get down to the business of building up our AppGW config. There are a few moving parts involved so let’s take a minute to review what they are.\nThe first concept we’ll talk about is the Backend Pool. This is essentially the destination that you’d like to route the traffic to. You can use either IP or FQDN to route the traffic. These could be VMs, Web Apps a Load Balancer - Backend Pool targets are pretty flexible.\nNext up are the HTTP settings. This is where you configure the Backend Pool’s destination port, cookie based session affinity, and if you’re using end to end SSL you’ll need to add the add the public key of the Backend Pool in .CER format. It’s pretty straightforward to extract the .CER from a PFX. Note, you can also attach a custom probe, which you can use to verify the health of Backend Pools that are not listening on standard ports. I bumped into an issue where I configured a custom probe to check the health of Backend Pools which were listening on port 443 and my Backend Pools were showing a status of ‘Unknown’ - do yourself a favor and use the default probes if you want to keep your hair. There is also another scenario where you’ll need to use a custom probe even when using default ports - when you want to pull the hostname from the Backend Http Settings.\nThat brings us to the Frontend port configuration. When we create our AppGW we’ll need to create a public IP that we’ll attach to the AppGW. When we have an IP we can go about creating some frontend ports. Traffic will hit the frontend port and then based on some listeners get routed to the appropriate Backend Pool. We’re going to configure two ports in our demo - 80 and 443. We’ll setup a redirect configuration to send traffic coming in over http on port 80 to https on 443.\nI’ve just mentioned listeners, so now we can cover what part a listener plays. The listener has a few properties, the frontend IP, the frontend port, the protocol (HTTP/HTTPS), and if HTTPS is selected we’ll associate the SSL cert as well.\nAnd finally, the rule. The rule is the glue that holds the listener with the backend pool. Rule’s have a reference to the listener, Backend Pool and backend HTTP Setting. Hopefully this will all make a bit more sense once we cover the “how to setup” bits.\nNow that we’ve gotten some of the terminology out of the way we can start building this thing up. We need to create a public IP address to assign to our AppGW - bear in mind this is a dynamic IP, static IP’s are not supported currently on the AppGW. I’ve been told by Azure support that the IP should only change if you stop the Application Gateway… This IP will not be used in your DNS mapping as it’s dynamic and it would suck to have all your sites die when Azure decides to reassign you a new IP. Instead we’ll want to set up a CNAME entry that points from your custom domain name to directly to your AppGW’s FQDN - we’ll get to that step in a bit.\n$publicip = New-AzureRmPublicIpAddress -ResourceGroupName appgw-RG -name AppGWIP ` -location $location -AllocationMethod Dynamic $gipconfig = New-AzureRmApplicationGatewayIPConfiguration -Name gatewayIP01 -Subnet $subnet Next up are the frontend ports.\n$appGWFEIpConfig = New-AzureRmApplicationGatewayFrontendIPConfig -Name \"GatewayFrontEndIp\" ` -PublicIPAddress $appGatewayIp $httpsFrontEndPort = New-AzureRmApplicationGatewayFrontendPort -Name \"https\" -Port 443 $httpFrontEndPort = New-AzureRmApplicationGatewayFrontendPort -Name \"http\" -Port 80 Remember when I mentioned the custom probes on default ports? Well now we can get into the deets of that. We need to set up probe health response match, which we’ll set to a response in the 200-399 range. Then we’ll create a probe config for each one of our Backend Pools.\n$match = New-AzureRmApplicationGatewayProbeHealthResponseMatch ` -StatusCode 200-399 # Get the new probes $site1Probe = New-AzureRmApplicationGatewayProbeConfig -Name \"site1Probe\" -Protocol Https ` -Path / -Interval 30 -Timeout 120 -UnhealthyThreshold 3 -PickHostNameFromBackendHttpSettings -Match $match $site2Probe = New-AzureRmApplicationGatewayProbeConfig -Name \"site1Probe\" -Protocol Https ` -Path / -Interval 30 -Timeout 120 -UnhealthyThreshold 3 -PickHostNameFromBackendHttpSettings -Match $match Moving on now to setting up the Backend Http Settings for our two Backend Pools.\n$site1HttpSettings = New-AzureRmApplicationGatewayBackendHttpSettings -Name \"site1HttpSettings\" ` -Port 443 -Protocol Https -CookieBasedAffinity Disabled -RequestTimeout 120 ` -HostName $customHostName1 -Probe $site1Probe $site2HttpSettings = New-AzureRmApplicationGatewayBackendHttpSettings -Name \"site2HttpSettings\" ` -Port 443 -Protocol Https -CookieBasedAffinity Disabled -RequestTimeout 120 ` -HostName $customHostName2 -Probe $site2Probe Now we can work on setting up the Backend Pools for our two Web Apps.\n$pool1 = New-AzureRmApplicationGatewayBackendAddressPool -Name pool01 -BackendFqdns $defaultHostName1 $pool2 = New-AzureRmApplicationGatewayBackendAddressPool -Name pool02 -BackendFqdns $defaultHostName2 On to the Listeners, for the HTTPS listeners we need to publish our cert up to the Application Gateway so we’ll get that setup and then create our HTTPS and HTTP listeners.\n$gwCert = New-AzureRmApplicationGatewaySSLCertificate -Name ohioazurewildcard ` -CertificateFile $pfxPath -Password $passString # HTTPS listeners $site1Listener443 = New-AzureRmApplicationGatewayHttpListener ` -Name \"Site1Listener443\" ` -Protocol Https ` -FrontendIPConfiguration $appGWFEIpConfig ` -FrontendPort $httpsFrontEndPort ` -HostName $customHostName1 ` -RequireServerNameIndication true ` -SslCertificate $gwCert $site2Listener443 = New-AzureRmApplicationGatewayHttpListener ` -Name \"Site2Listener443\" ` -Protocol Https ` -FrontendIPConfiguration $appGWFEIpConfig ` -FrontendPort $httpsFrontEndPort ` -HostName $customHostName2 ` -RequireServerNameIndication true ` -SslCertificate $gwCert # HTTP listeners $site1Listener80 = New-AzureRmApplicationGatewayHttpListener ` -Name \"Site1Listener80\" ` -Protocol Http ` -FrontendIPConfiguration $appGWFEIpConfig ` -FrontendPort $httpFrontEndPort ` -HostName $customHostName1 $site2Listener80 = New-AzureRmApplicationGatewayHttpListener ` -Name \"Site2Listener80\" ` -Protocol Http ` -FrontendIPConfiguration $appGWFEIpConfig ` -FrontendPort $httpFrontEndPort ` -HostName $customHostName2 Now that we have our listeners created we can go about setting up the 80 = 443 site redirects. You can see here we’re creating 2 redirection configurations - one for each site. The important piece here is the -TargetListener.\n$site1RedirectConfig = New-AzureRmApplicationGatewayRedirectConfiguration -Name \"redirectSite1\" ` -RedirectType Permanent -TargetListener $site1Listener443 $site2RedirectConfig = New-AzureRmApplicationGatewayRedirectConfiguration -Name \"redirectSite2\" ` -RedirectType Permanent -TargetListener $site2Listener443 We are getting close to finished here. We still need to setup the routing rules. We’ll need 2 routing rules for each site. One will be the redirect routing rule, and the other will route the traffic to the backend pool specific to the hostname in the listener.\n# Redirect routing rules $site1RedirectRule = New-AzureRmApplicationGatewayRequestRoutingRule -Name \"site1RedirectRule\" ` -RuleType Basic -HttpListener $site1Listener80 -RedirectConfiguration $site1RedirectConfig $site2RedirectRule = New-AzureRmApplicationGatewayRequestRoutingRule -Name \"site2RedirectRule\" ` -RuleType Basic -HttpListener $site2Listener80 -RedirectConfiguration $site2RedirectConfig # Backend pool routing rule $site1Rule = New-AzureRmApplicationGatewayRequestRoutingRule -Name \"site1Rule\" ` -RuleType Basic -HttpListener $site1Listener443 -BackendHttpSettings $site1HttpSettings ` -BackendAddressPool $pool1 $site2Rule = New-AzureRmApplicationGatewayRequestRoutingRule -Name \"site2Rule\" ` -RuleType Basic -HttpListener $site2Listener443 -BackendHttpSettings $site2HttpSettings ` -BackendAddressPool $pool2 Next we can set the sku for the Application Gateway. Remember WAF is an extra charge so you’ll want to make sure you choose the appropriate sku here. Also, Azure recommends 2 Application Gateways for high availability. Also, make sure to create a WAF configuration so that you can enable your WAF when the Application Gateway comes up.\n$Sku = New-AzureRmApplicationGatewaySku -Name \"WAF_Medium\" -Tier \"WAF\" -Capacity 2 $wafConfig = New-AzureRmApplicationGatewayWebApplicationFirewallConfiguration -Enabled $true -FirewallMode \"Prevention\" And here we are, finally about to create our Application Gateway. We need to make sure and pass along all the required configuration objects.\n$appgw = New-AzureRmApplicationGateway -Name appgw ` -ResourceGroupName $rgName ` -Location $location ` -BackendAddressPools $pool1,$pool2 ` -BackendHttpSettingsCollection $site1HttpSettings,$site2HttpSettings ` -FrontendIpConfigurations $appGWFEIpConfig ` -GatewayIpConfigurations $gipconfig ` -FrontendPorts $httpsFrontEndPort,$httpFrontEndPort ` -HttpListeners $site1Listener443,$site2Listener443,$site1Listener80,$site2Listener80 ` -RequestRoutingRules $site1RedirectRule,$site1RedirectRule,$site1Rule,$site1Rule ` -Sku $Sku ` -WebApplicationFirewallConfig $wafConfig -SslCertificates $gwCert ` -Probes $site1Probe,$site2Probe ` -RedirectConfigurations $site1RedirectConfig,$site2RedirectConfig These Application Gateways take a little while to deploy, so if you’ve made it this far now is the perfect time to go find yourself a fresh cup ‘o joe. When the deployment is complete, we’ll need to update the CNAME records that we previously pointed directly at the Web Apps to point at the Application Gateway.\nIf your DNS zone is hosted in Azure then you’re a few lines of Powershell away from a wrap. First we’ll get the FQDN of the new Application Gateway, then we update the entries.\n$gatewayFQDN = ((Get-AzureRmPublicIpAddress -ResourceGroupName $rgName -Name AppGWIP).DnsSettings).Fqdn $site1RecordSet = Get-AzureRmDnsRecordSet -Name \"site1\" -RecordType CNAME -ZoneName \"OhioAzure.com\" -ResourceGroupName OhioAzureDomain $site1RecordSet.Records[0].Cname = $gatewayFQDN Set-AzureRmDnsRecordSet -RecordSet $site1RecordSet $site2RecordSet = Get-AzureRmDnsRecordSet -Name \"site2\" -RecordType CNAME -ZoneName \"OhioAzure.com\" -ResourceGroupName OhioAzureDomain $site2RecordSet.Records[0].Cname = $gatewayFQDN Set-AzureRmDnsRecordSet -RecordSet $site2RecordSet So there you have it. A working end to end SSL multi-site redirect enabled WAF Application Gateway. Enjoy.\nIf you’re using a self signed cert like I did then your browser will give you a warning - feel free to ignore.\n","wordCount":"1515","inLanguage":"en","datePublished":"2018-01-29T10:43:42-05:00","dateModified":"2018-01-29T10:43:42-05:00","author":{"@type":"Person","name":"Colin Detwiller"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://colin.detwiller.me/posts/azureapplicationgatwaypart2/"},"publisher":{"@type":"Organization","name":"Colin's blog","logo":{"@type":"ImageObject","url":"https://colin.detwiller.me/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<ul id=menu>
<li>
<a href=https://colin.detwiller.me/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://colin.detwiller.me/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://colin.detwiller.me/>Home</a>&nbsp;»&nbsp;<a href=https://colin.detwiller.me/posts/>Posts</a></div>
<h1 class=post-title>
Azure Application Gateway - Part 2
</h1>
<div class=post-meta><span title="2018-01-29 10:43:42 -0500 EST">January 29, 2018</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Colin Detwiller
</div>
</header>
<div class=post-content><p>This is a continuation from part one on setting up an <a href=/post/azureapplicationgatwaypart1>Azure Application Gateway Part 1</a>.</p>
<p>Next on our hit list is creating an Azure VNet to hold our AppGW. The AppGW has to live in an AppGW subnet, the only other thing that can reside in the same subnet are other AppGW&rsquo;s and hopefully you&rsquo;ll only need one since the AppGW is capable of serving up to 20 sites, with various limits around authentication certs for backend re-encryption.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$gwSubnetName = <span style=color:#e6db74>&#39;appgwsubnet&#39;</span>
$subnet = New-AzureRmVirtualNetworkSubnetConfig -Name $gwSubnetName `
    -AddressPrefix 10.0.0.0/28
$vnet = New-AzureRmVirtualNetwork -Name appgwvnet -ResourceGroupName appgw-RG `
    -Location $location -AddressPrefix 10.0.0.0/16 -Subnet $subnet
$subnet = Get-AzureRmVirtualNetworkSubnetConfig -Name $gwSubnetName `
    -VirtualNetwork $vnet
</code></pre></div><p>OK, now we can get down to the business of building up our AppGW config. There are a few moving parts involved so let&rsquo;s take a minute to review what they are.</p>
<p>The first concept we&rsquo;ll talk about is the Backend Pool. This is essentially the destination that you&rsquo;d like to route the traffic to. You can use either IP or FQDN to route the traffic. These could be VMs, Web Apps a Load Balancer - Backend Pool targets are pretty flexible.</p>
<p>Next up are the HTTP settings. This is where you configure the Backend Pool&rsquo;s destination port, cookie based session affinity, and if you&rsquo;re using end to end SSL you&rsquo;ll need to add the add the public key of the Backend Pool in .CER format. It&rsquo;s pretty straightforward to extract the .CER from a PFX. Note, you can also attach a custom probe, which you can use to verify the health of Backend Pools that are not listening on standard ports. I bumped into an issue where I configured a custom probe to check the health of Backend Pools which were listening on port 443 and my Backend Pools were showing a status of &lsquo;Unknown&rsquo; - do yourself a favor and use the default probes if you want to keep your hair. There is also another scenario where you&rsquo;ll need to use a custom probe even when using default ports - when you want to pull the hostname from the Backend Http Settings.</p>
<p>That brings us to the Frontend port configuration. When we create our AppGW we&rsquo;ll need to create a public IP that we&rsquo;ll attach to the AppGW. When we have an IP we can go about creating some frontend ports. Traffic will hit the frontend port and then based on some listeners get routed to the appropriate Backend Pool. We&rsquo;re going to configure two ports in our demo - 80 and 443. We&rsquo;ll setup a redirect configuration to send traffic coming in over http on port 80 to https on 443.</p>
<p>I&rsquo;ve just mentioned listeners, so now we can cover what part a listener plays. The listener has a few properties, the frontend IP, the frontend port, the protocol (HTTP/HTTPS), and if HTTPS is selected we&rsquo;ll associate the SSL cert as well.</p>
<p>And finally, the rule. The rule is the glue that holds the listener with the backend pool. Rule&rsquo;s have a reference to the listener, Backend Pool and backend HTTP Setting. Hopefully this will all make a bit more sense once we cover the &ldquo;how to setup&rdquo; bits.</p>
<p>Now that we&rsquo;ve gotten some of the terminology out of the way we can start building this thing up. We need to create a public IP address to assign to our AppGW - bear in mind this is a dynamic IP, static IP&rsquo;s are not supported currently on the AppGW. I&rsquo;ve been told by Azure support that the IP <em>should</em> only change if you stop the Application Gateway&mldr;
This IP will not be used in your DNS mapping as it&rsquo;s dynamic and it would suck to have all your sites die when Azure decides to reassign you a new IP. Instead we&rsquo;ll want to set up a CNAME entry that points from your custom domain name to directly to your AppGW&rsquo;s FQDN - we&rsquo;ll get to that step in a bit.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$publicip = New-AzureRmPublicIpAddress -ResourceGroupName appgw-RG -name AppGWIP `
                -location $location -AllocationMethod Dynamic 
$gipconfig = New-AzureRmApplicationGatewayIPConfiguration -Name gatewayIP01 -Subnet $subnet
</code></pre></div><p>Next up are the frontend ports.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$appGWFEIpConfig = New-AzureRmApplicationGatewayFrontendIPConfig -Name <span style=color:#e6db74>&#34;GatewayFrontEndIp&#34;</span> `
                    -PublicIPAddress $appGatewayIp
$httpsFrontEndPort = New-AzureRmApplicationGatewayFrontendPort -Name <span style=color:#e6db74>&#34;https&#34;</span> -Port 443
$httpFrontEndPort = New-AzureRmApplicationGatewayFrontendPort -Name <span style=color:#e6db74>&#34;http&#34;</span> -Port 80  
</code></pre></div><p>Remember when I mentioned the custom probes on default ports? Well now we can get into the deets of that.
We need to set up probe health response match, which we&rsquo;ll set to a response in the 200-399 range. Then we&rsquo;ll create a probe config for each one of our Backend Pools.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$match = New-AzureRmApplicationGatewayProbeHealthResponseMatch `
            -StatusCode 200-399

<span style=color:#75715e># Get the new probes</span>
$site1Probe  = New-AzureRmApplicationGatewayProbeConfig  -Name <span style=color:#e6db74>&#34;site1Probe&#34;</span> -Protocol Https `
        -Path / -Interval 30 -Timeout 120 -UnhealthyThreshold 3 -PickHostNameFromBackendHttpSettings <span style=color:#f92672>-Match</span> $match

$site2Probe  = New-AzureRmApplicationGatewayProbeConfig  -Name <span style=color:#e6db74>&#34;site1Probe&#34;</span> -Protocol Https `
        -Path / -Interval 30 -Timeout 120 -UnhealthyThreshold 3 -PickHostNameFromBackendHttpSettings <span style=color:#f92672>-Match</span> $match
</code></pre></div><p>Moving on now to setting up the Backend Http Settings for our two Backend Pools.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$site1HttpSettings = New-AzureRmApplicationGatewayBackendHttpSettings -Name <span style=color:#e6db74>&#34;site1HttpSettings&#34;</span> `
        -Port 443 -Protocol Https -CookieBasedAffinity Disabled -RequestTimeout 120 `
        -HostName $customHostName1 -Probe $site1Probe

$site2HttpSettings = New-AzureRmApplicationGatewayBackendHttpSettings -Name <span style=color:#e6db74>&#34;site2HttpSettings&#34;</span> `
        -Port 443 -Protocol Https -CookieBasedAffinity Disabled -RequestTimeout 120 `
        -HostName $customHostName2 -Probe $site2Probe
</code></pre></div><p>Now we can work on setting up the Backend Pools for our two Web Apps.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$pool1 = New-AzureRmApplicationGatewayBackendAddressPool -Name pool01 -BackendFqdns $defaultHostName1
$pool2 = New-AzureRmApplicationGatewayBackendAddressPool -Name pool02 -BackendFqdns $defaultHostName2
</code></pre></div><p>On to the Listeners, for the HTTPS listeners we need to publish our cert up to the Application Gateway so we&rsquo;ll get that setup and then create our HTTPS and HTTP listeners.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$gwCert = New-AzureRmApplicationGatewaySSLCertificate -Name ohioazurewildcard `
    -CertificateFile $pfxPath -Password $passString

<span style=color:#75715e># HTTPS listeners</span>
$site1Listener443 = New-AzureRmApplicationGatewayHttpListener `
    -Name <span style=color:#e6db74>&#34;Site1Listener443&#34;</span> `
    -Protocol Https `
    -FrontendIPConfiguration $appGWFEIpConfig `
    -FrontendPort $httpsFrontEndPort `
    -HostName $customHostName1 `
    -RequireServerNameIndication true  `
    -SslCertificate $gwCert

$site2Listener443 = New-AzureRmApplicationGatewayHttpListener `
        -Name <span style=color:#e6db74>&#34;Site2Listener443&#34;</span> `
        -Protocol Https `
        -FrontendIPConfiguration $appGWFEIpConfig `
        -FrontendPort $httpsFrontEndPort `
        -HostName $customHostName2 `
        -RequireServerNameIndication true  `
        -SslCertificate $gwCert

<span style=color:#75715e># HTTP listeners</span>
$site1Listener80 = New-AzureRmApplicationGatewayHttpListener `
        -Name <span style=color:#e6db74>&#34;Site1Listener80&#34;</span> `
        -Protocol Http `
        -FrontendIPConfiguration $appGWFEIpConfig `
        -FrontendPort $httpFrontEndPort `
        -HostName $customHostName1

$site2Listener80 = New-AzureRmApplicationGatewayHttpListener `
        -Name <span style=color:#e6db74>&#34;Site2Listener80&#34;</span> `
        -Protocol Http `
        -FrontendIPConfiguration $appGWFEIpConfig `
        -FrontendPort $httpFrontEndPort `
        -HostName $customHostName2 
</code></pre></div><p>Now that we have our listeners created we can go about setting up the 80 => 443 site redirects. You can see here we&rsquo;re creating 2 redirection configurations - one for each site. The important piece here is the <code>-TargetListener</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$site1RedirectConfig = New-AzureRmApplicationGatewayRedirectConfiguration -Name <span style=color:#e6db74>&#34;redirectSite1&#34;</span> `
    -RedirectType Permanent -TargetListener $site1Listener443

$site2RedirectConfig = New-AzureRmApplicationGatewayRedirectConfiguration -Name <span style=color:#e6db74>&#34;redirectSite2&#34;</span> `
    -RedirectType Permanent -TargetListener $site2Listener443
</code></pre></div><p>We are getting close to finished here. We still need to setup the routing rules. We&rsquo;ll need 2 routing rules for each site. One will be the redirect routing rule, and the other will route the traffic to the backend pool specific to the hostname in the listener.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#75715e># Redirect routing rules</span>
$site1RedirectRule = New-AzureRmApplicationGatewayRequestRoutingRule -Name <span style=color:#e6db74>&#34;site1RedirectRule&#34;</span> `
    -RuleType Basic -HttpListener $site1Listener80 -RedirectConfiguration $site1RedirectConfig
$site2RedirectRule = New-AzureRmApplicationGatewayRequestRoutingRule -Name <span style=color:#e6db74>&#34;site2RedirectRule&#34;</span> `
    -RuleType Basic -HttpListener $site2Listener80 -RedirectConfiguration $site2RedirectConfig
<span style=color:#75715e># Backend pool routing rule</span>
$site1Rule = New-AzureRmApplicationGatewayRequestRoutingRule -Name <span style=color:#e6db74>&#34;site1Rule&#34;</span> `
    -RuleType Basic -HttpListener $site1Listener443 -BackendHttpSettings $site1HttpSettings `
    -BackendAddressPool $pool1

$site2Rule = New-AzureRmApplicationGatewayRequestRoutingRule -Name <span style=color:#e6db74>&#34;site2Rule&#34;</span> `
    -RuleType Basic -HttpListener $site2Listener443 -BackendHttpSettings $site2HttpSettings `
    -BackendAddressPool $pool2
</code></pre></div><p>Next we can set the sku for the Application Gateway. Remember WAF is an extra charge so you&rsquo;ll want to make sure you choose the appropriate sku here. Also, Azure recommends 2 Application Gateways for high availability. Also, make sure to create a WAF configuration so that you can enable your WAF when the Application Gateway comes up.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$Sku = New-AzureRmApplicationGatewaySku -Name <span style=color:#e6db74>&#34;WAF_Medium&#34;</span> -Tier <span style=color:#e6db74>&#34;WAF&#34;</span> -Capacity 2

$wafConfig = New-AzureRmApplicationGatewayWebApplicationFirewallConfiguration -Enabled $true -FirewallMode <span style=color:#e6db74>&#34;Prevention&#34;</span>
</code></pre></div><p>And here we are, finally about to create our Application Gateway. We need to make sure and pass along all the required configuration objects.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$appgw = New-AzureRmApplicationGateway -Name appgw `
            -ResourceGroupName $rgName `
            -Location $location `
            -BackendAddressPools $pool1,$pool2 `
            -BackendHttpSettingsCollection $site1HttpSettings,$site2HttpSettings `
            -FrontendIpConfigurations $appGWFEIpConfig `
            -GatewayIpConfigurations $gipconfig  `
            -FrontendPorts $httpsFrontEndPort,$httpFrontEndPort `
            -HttpListeners $site1Listener443,$site2Listener443,$site1Listener80,$site2Listener80 `
            -RequestRoutingRules $site1RedirectRule,$site1RedirectRule,$site1Rule,$site1Rule `
            -Sku $Sku `
            -WebApplicationFirewallConfig $wafConfig
            -SslCertificates $gwCert `
            -Probes $site1Probe,$site2Probe `
            -RedirectConfigurations $site1RedirectConfig,$site2RedirectConfig
</code></pre></div><p>These Application Gateways take a little while to deploy, so if you&rsquo;ve made it this far now is the perfect time to go find yourself a fresh cup &lsquo;o joe. When the deployment is complete, we&rsquo;ll need to update the CNAME records that we previously pointed directly at the Web Apps to point at the Application Gateway.</p>
<p>If your DNS zone is hosted in Azure then you&rsquo;re a few lines of Powershell away from a wrap. First we&rsquo;ll get the FQDN of the new Application Gateway, then we update the entries.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>$gatewayFQDN = ((Get-AzureRmPublicIpAddress -ResourceGroupName $rgName -Name AppGWIP).DnsSettings).Fqdn

$site1RecordSet = Get-AzureRmDnsRecordSet -Name <span style=color:#e6db74>&#34;site1&#34;</span> -RecordType CNAME -ZoneName <span style=color:#e6db74>&#34;OhioAzure.com&#34;</span> -ResourceGroupName OhioAzureDomain
$site1RecordSet.Records[0].Cname = $gatewayFQDN
Set-AzureRmDnsRecordSet -RecordSet $site1RecordSet

$site2RecordSet = Get-AzureRmDnsRecordSet -Name <span style=color:#e6db74>&#34;site2&#34;</span> -RecordType CNAME -ZoneName <span style=color:#e6db74>&#34;OhioAzure.com&#34;</span> -ResourceGroupName OhioAzureDomain
$site2RecordSet.Records[0].Cname = $gatewayFQDN
Set-AzureRmDnsRecordSet -RecordSet $site2RecordSet
</code></pre></div><p>So there you have it. A working end to end SSL multi-site redirect enabled WAF Application Gateway. Enjoy.</p>
<p>If you&rsquo;re using a self signed cert like I did then your browser will give you a warning - feel free to ignore.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://colin.detwiller.me/tags/load-balancing/>load balancing</a></li>
<li><a href=https://colin.detwiller.me/tags/azure/>azure</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://colin.detwiller.me/posts/javascript-reverse-string/>
<span class=title>« Prev Page</span>
<br>
<span>Javascript Reverse String</span>
</a>
<a class=next href=https://colin.detwiller.me/posts/azureapplicationgatwaypart1/>
<span class=title>Next Page »</span>
<br>
<span>Azure Application Gateway - Part 1</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Azure Application Gateway - Part 2 on twitter" href="https://twitter.com/intent/tweet/?text=Azure%20Application%20Gateway%20-%20Part%202&url=https%3a%2f%2fcolin.detwiller.me%2fposts%2fazureapplicationgatwaypart2%2f&hashtags=loadbalancing%2cazure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Azure Application Gateway - Part 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcolin.detwiller.me%2fposts%2fazureapplicationgatwaypart2%2f&title=Azure%20Application%20Gateway%20-%20Part%202&summary=Azure%20Application%20Gateway%20-%20Part%202&source=https%3a%2f%2fcolin.detwiller.me%2fposts%2fazureapplicationgatwaypart2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Azure Application Gateway - Part 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcolin.detwiller.me%2fposts%2fazureapplicationgatwaypart2%2f&title=Azure%20Application%20Gateway%20-%20Part%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://colin.detwiller.me/>Colin's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>